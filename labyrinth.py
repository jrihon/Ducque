import sys, os, json
import numpy as np

import labyrinth_func as LabF

""" Create dictionary of the filename and their molecule code """

codex_acidum_nucleicum = {
"dT": ["json/dna_thymidine.json", "json/dna_phosphate.json"],
"dA": ["json/dna_adenosine.json", "json/dna_phosphate.json"],
"dC": ["json/dna_cytidine.json", "json/dna_phosphate.json"],
"dG": ["json/dna_guanosine.json", "json/dna_phosphate.json"],
}

def Architecture(nucleic_acid_list, complement):
    """ This function contains all the functions to create the nucleic acid duplex.

    First up, a bottom-up approach is applied when building the nucleic acid single strand.

    A complementary strand is generated by fitting the nucleosides and linker elements, in a bottom-up approach, to the leading strand.

    Finally, a pdb is outputted, with the two chains in present. """

    # Reverse the list order, because we build the nucleoside from the bottom up.
    nucleic_acid_list.reverse()

    # Start the index counter. We will need this when we position the complementary nucleotides
    index_counter = 0
    # Parse the first nucleotide in the list.
    nucleic_acid = nucleic_acid_list[0]

    # Parse dictionary for the correct filename; input(DT) - output(dna_thymidine.json). This also parses the correct linker.
    nucleoside = LabF.Nucleoside(codex_acidum_nucleicum[nucleic_acid][0]) ; index_counter += nucleoside.mol_length
    linker = LabF.Desmos(codex_acidum_nucleicum[nucleic_acid][1]) ; index_counter += linker.mol_length

    # Position the linker moiety on the nucleoside.
    leading_strand = LabF.position_phosphate_linker(nucleoside, nucleoside.array, linker)

    num_nucl = 1 # Initiate a counter

    # This for loop positions the subsequent nucleotides of the leading strand.
    for NA in range(1, len(nucleic_acid_list)):

        # Import the next nucleoside and create an object
        nextnuc_acid = nucleic_acid_list[NA]
        nextnuc = LabF.Nucleoside(codex_acidum_nucleicum[nextnuc_acid][0]) ; index_counter += nextnuc.mol_length
        nextlink = LabF.Desmos(codex_acidum_nucleicum[nextnuc_acid][1]) ; index_counter += nextlink.mol_length

        # Parse the dictionary for the previous nucleotide, to append the next nucleotide onto.
        previous_nucleic_acid = nucleic_acid_list[NA - 1]
        # Parse the correct nucleoside and linker and create them as objects
        prevnuc, prevlink = LabF.Nucleoside(codex_acidum_nucleicum[previous_nucleic_acid][0]), LabF.Desmos(codex_acidum_nucleicum[previous_nucleic_acid][1])

        # Position the following nucleoside in the sequence
        next_nucleoSIDE_positioned = LabF.position_next_nucleoside(nextnuc, prevnuc, prevlink, leading_strand)

        # Position the following linker to create a nucleotide array
        if not (NA + 1) == len(nucleic_acid_list):
            # If this is not the last nucleoside in the sequence, build a linker onto it.
            next_nucleoTIDE_positioned = LabF.position_phosphate_linker(nextnuc, next_nucleoSIDE_positioned, nextlink)

            # Create a tuple of the two arrays and stack them. This becomes the leading strand upon which we continue appending nucleotides.
            leading_strand = np.vstack((next_nucleoTIDE_positioned, leading_strand))
        else:
            # Leave the object as a nucleoside, since it is the last one in the sequence. Create a tuple of the two arrays to finalise the leading strand.
            leading_strand = np.vstack((next_nucleoSIDE_positioned, leading_strand))
            index_counter -= nextlink.mol_length

        num_nucl += 1

    # Generate a list of complementary nucleotides
    compl_nucleic_acid_list = LabF.generate_complementary_sequence(nucleic_acid_list, complement)

    # Retro-actively fit in the bases
    LabF.position_complementary_base(index_counter)



    #------------------------ CREATE THE PDB THAT GOES WITH ARRAY INPUTTED -------------------#
    print("\nNumber of nucleotides in the duplex :" , num_nucl, "\n")
    #print("Count of index is : ", index_counter)
    LabF.create_PDB_from_matrix(leading_strand, nucleic_acid_list)
